%{#ifndef _BLURB_
#define _BLURB_
/*

            Coda: an Experimental Distributed File System
                             Release 4.0

          Copyright (c) 1987-1996 Carnegie Mellon University
                         All Rights Reserved

Permission  to  use, copy, modify and distribute this software and its
documentation is hereby granted,  provided  that  both  the  copyright
notice  and  this  permission  notice  appear  in  all  copies  of the
software, derivative works or  modified  versions,  and  any  portions
thereof, and that both notices appear in supporting documentation, and
that credit is given to Carnegie Mellon University  in  all  documents
and publicity pertaining to direct or indirect use of this code or its
derivatives.

CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
ANY DERIVATIVE WORK.

Carnegie  Mellon  encourages  users  of  this  software  to return any
improvements or extensions that  they  make,  and  to  grant  Carnegie
Mellon the rights to redistribute these changes without encumbrance.
*/

static char *rcsid = "$Header: /afs/cs/project/coda-src/cvs/coda/coda-src/auth2/auth2.rpc2,v 4.3.2.1 1998/05/15 16:50:47 braam Exp $";
#endif /*_BLURB_*/%}




/*

                         IBM COPYRIGHT NOTICE

                          Copyright (C) 1986
             International Business Machines Corporation
                         All Rights Reserved

This  file  contains  some  code identical to or derived from the 1986
version of the Andrew File System ("AFS"), which is owned by  the  IBM
Corporation.    This  code is provded "AS IS" and IBM does not warrant
that it is free of infringement of  any  intellectual  rights  of  any
third  party.    IBM  disclaims  liability of any kind for any damages
whatsoever resulting directly or indirectly from use of this  software
or  of  any  derivative work.  Carnegie Mellon University has obtained
permission to distribute this code, which is based on Version 2 of AFS
and  does  not  contain the features and enhancements that are part of
Version 3 of AFS.  Version 3 of  AFS  is  commercially  available  and
supported by Transarc Corporation, Pittsburgh, PA.

*/

Server Prefix "S";
Subsystem  "auth2";

/* The portal for RPC.  Must exist in /etc/services. */
#define AUTH_SERVICE	"codaauth2"

/* The subsysid for auth server; use RPC2_SUBSYSBYID */
#define AUTH_SUBSYSID	1993253

/* Return codes from AuthChangePassword */
#define AUTH_SUCCESS	0
#define AUTH_FAILED	1
#define AUTH_DENIED	2
#define AUTH_BADKEY	3
#define AUTH_READONLY	4

/* Authentication mechanisms supported by AuthenticationType */
#define AUTH_METHOD_NULL		0 /* for OK */
#define AUTH_METHOD_CODATOKENS		1 /* using session key */
#define AUTH_METHOD_CODAUSERNAME	2 /* old type login */
#define AUTH_METHOD_KERBEROS4		3 /* use existing TGT */
#define AUTH_METHOD_KERBEROS5		4 /* use existing TGT */
#define AUTH_METHOD_PK			5 /* for the future */

/* Vice Ioctls for authentication calls */
/*  #define AUTH_GETVICEID	16	Not yet implemented */
#define AUTH_SETTOKENS		3
#define AUTH_GETTOKENS		9
#define AUTH_DELETETOKENS	8

/* The result of an AuthGetToken() call is to return an ClearToken and
   an SecretToken.  The two contain similar information, but
   SecretToken has its fields permuted, has a magic string for
   self-validation and has noise fields to resist plaintext attacks.  */

typedef RPC2_Byte AuthMagic[16];
#define AUTH_MAGICVALUE "authentication"

typedef RPC2_Struct {
	AuthMagic MagicString;	/* Value should be equal to the magic
				   string of the day. If so, encrypted
				   token is valid. */
	RPC2_Integer AuthHandle;	/* Handle, might come in
					   useful for revocation in future */
	RPC2_Integer Noise1;
	RPC2_Integer ViceId;		/* Whom is this token for? */
	RPC2_Integer BeginTimestamp;	/* Seconds since Jan 1 1970
					   before which token is invalid */
	RPC2_Integer Noise2;
	RPC2_Integer EndTimestamp;	/* Seconds since Jan 1 1970
					   after which token is invalid */
	RPC2_Integer Noise3;
	RPC2_EncryptionKey  HandShakeKey;	/* For use by server's
						   GetKeys() routine */
	RPC2_Integer Noise4;
} SecretToken;

typedef RPC2_Byte EncryptedSecretToken[56];
typedef RPC2_Struct {
	RPC2_Integer AuthHandle;
	RPC2_EncryptionKey HandShakeKey;
	RPC2_Integer ViceId;
	RPC2_Integer BeginTimestamp;
	RPC2_Integer EndTimestamp;
} ClearToken;

/* NOTE: The auth server accepts only secure connections based on the
   stored password of a user */

AuthNewConn (IN RPC2_Integer seType, IN RPC2_Integer secLevel, IN RPC2_Integer encType, IN RPC2_Integer AuthenticationType, IN RPC2_CountedBS cIdent) NEW_CONNECTION;

/* Change a user's password. You can change your own password always.
Caller must be a system administrator to change someone else's
password. */

1: AuthChangePasswd (IN RPC2_Integer viceId, IN RPC2_String newPasswd);

/* Get back tokens for use in communicating with File Servers.  This
   is effectively a key distribution algorithm, since the tokens
   contain a session key.  You use a secure connection to get to the
   auth server, then get tokens, then use the auth token to establish
   a secure connection with a file server.  The sToken is encrypted
   with a key known only to the auth server and the file servers.  It
   is transmitted by the client as the ClientIdent field of the
   RPC2_Bind() to the file server.  */

2: AuthGetTokens (OUT EncryptedSecretToken sToken, OUT ClearToken cToken);

/* Changes entry for a user. Caller must be a system administrator.  */

3: AuthChangeUser (IN RPC2_Integer viceId, IN RPC2_EncryptionKey initKey, 
		   IN RPC2_String otherInfo);

/* Adds a new user to Vice. Caller must be a system administrator.
   User must not exist already */

4: AuthNewUser (IN RPC2_Integer viceId, IN RPC2_EncryptionKey initKey, 
		IN RPC2_String otherInfo);
	
/* Deletes a user from vice.  User must exist. Note that viceId
   remains in use.  However the user cannot authenticate himself to
   Vice.  Caller must be a system administrator.  */

5: AuthDeleteUser (IN RPC2_Integer viceId);
	
/* Returns the vice id corr to vice name.  Returns  AUTHFAILED
   if  viceName is a bogus vice name. Else returns AUTHSUCCESS.
*/

6: AuthNameToId (IN RPC2_String viceName, OUT RPC2_Integer viceId);

/* Logout from server: marks connection as not in use; gc it
   later. Can't just unbind since response will not get back */

7: AuthQuit();	
