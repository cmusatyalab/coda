#! /bin/sh
#ifndef _BLURB_
#define _BLURB_
#/*
#
#            Coda: an Experimental Distributed File System
#                             Release 4.0
#
#          Copyright (c) 1987-1996 Carnegie Mellon University
#                         All Rights Reserved
#
#Permission  to  use, copy, modify and distribute this software and its
#documentation is hereby granted,  provided  that  both  the  copyright
#notice  and  this  permission  notice  appear  in  all  copies  of the
#software, derivative works or  modified  versions,  and  any  portions
#thereof, and that both notices appear in supporting documentation, and
#that credit is given to Carnegie Mellon University  in  all  documents
#and publicity pertaining to direct or indirect use of this code or its
#derivatives.
#
#CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
#SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
#FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
#DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
#RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
#ANY DERIVATIVE WORK.
#
#Carnegie  Mellon  encourages  users  of  this  software  to return any
#improvements or extensions that  they  make,  and  to  grant  Carnegie
#Mellon the rights to redistribute these changes without encumbrance.
#*/
#
#static char *rcsid = "$Header: blurb.doc,v 1.1 96/11/22 13:29:31 raiff Exp $";
#endif /*_BLURB_*/

# The next line restarts using wish\
exec /coda/misc/tcl/@sys/beta/bin/wish "$0" "$@"

proc mkbuttons {frame} {
   radiobutton $frame.remove -text "Remove inconsistent file" -variable action \
	-value remove 
   radiobutton $frame.latest -text "Use one of the replicas as the new version" \
	-variable action -value latest 

   #frame for the button and entry for specifying a new file
   frame $frame.newfile
   frame $frame.newfile.fname
   radiobutton $frame.newfile.but -text "Use another file" \
	-variable action -value name 
   entry $frame.newfile.fname.ent -width 30 -relief sunken \
	-xscrollcommand "$frame.newfile.fname.sb set";
   bind $frame.newfile.fname.ent <Return> "set action name; repairwithnamedfile $frame.newfile.fname.ent"
   scrollbar $frame.newfile.fname.sb -relief flat -orient horiz \
	-command "$frame.newfile.fname.ent xview";
   pack append $frame.newfile.fname $frame.newfile.fname.sb {bottom fill} \
	$frame.newfile.fname.ent top

   pack append $frame.newfile $frame.newfile.fname {top right} $frame.newfile.but {top left padx 10}

   frame $frame.replicas
   getreplicas $frame.replicas

   pack $frame.remove -side top -padx 150 -pady 10 -anchor w
   pack $frame.newfile -side top -padx 150 -pady 10 -anchor w
   pack $frame.latest -side top -padx 150 -pady 10 -anchor w
   pack $frame.replicas -side top -padx 0 -pady 10 -anchor center
}

proc GetIncResp {{w .f}} {
   global action
   global oname

   set sl [string length $oname]
   if {$sl > 0} {set width $sl} {set width 15}

   #frame for announcing what has happened
   message $w.announce -font -Adobe-times-medium-r-normal--*-180* \
	-relief raised -width [expr $width]c \
	-text "repairing inconsistent file $oname"

   # frame for making the buttons
   frame $w.actionbuttons 
   mkbuttons $w.actionbuttons

   #frame for placing the ok/cancel buttons
   frame $w.finalize 
   button $w.finalize.ok -text "OK" -command { \
	case $action in {
	     nothing 	{ exit 0 }
	     remove 	{ exit 1 } 
	     latest 	{ oklistboxcommand .f.actionbuttons.replicas.entries.l }
	     name 	{ repairwithnamedfile .f.actionbuttons.newfile.fname.ent }
	     default 	{ exit -1 }
	}
   }
   button $w.finalize.cancel -text "Cancel" -command {\
	destroy .
	exit 0
   }
   pack append $w.finalize $w.finalize.ok {left} $w.finalize.cancel {right}

   pack append $w $w.announce {top fillx } \
      $w.actionbuttons {top fillx } \
      $w.finalize {bottom fillx}

   bind $w <KeyPress-Return> {puts stdout "returning $action"; return $action}
}

proc getreplicas {frame} {
   #make a frame 
   $frame configure  -width 80c -height 3

   #put a frame for displaying the replicas
   frame $frame.entries

   canvas $frame.message -height 1c -width 20c
   pack append $frame $frame.message {bottom fillx}\
	$frame.entries {top fillx}
   makeentries $frame.entries
   getentries $frame.entries.l
}

#make the listbox (and the scrollbar) for displaying the replicas 
proc makeentries {entry} {
  listbox $entry.l -relief raised -bd 2 -width 80 -height 3 \
	-font -Adobe-Courier-medium-r-normal--*-120*
  pack append $entry $entry.l {expand fill}
}

# get the meta information for each replica and insert into listbox
proc getentries {listbox} {
   global children nreplicas oname
   set cwd [pwd]
   cd $oname
   for {set i 0} {$i < $nreplicas} {incr i +1} {
      set newentry [exec ls -l [lindex $children $i]]
      $listbox insert end $newentry
   }
   $listbox select set 0 active
   cd $cwd 
}

# procedure invoked when ok is pressed
proc oklistboxcommand {listbox} {
   global children oname 
   set cs [$listbox curselection]
   set howmanyentries [llength $cs] 
   if {$howmanyentries == 0} {
      set echotext "You need to select an entry first" 
      set i [.f.actionbuttons.replicas.message create text 6c 0.3c -text "$echotext" -fill red -anchor nw]
      after 1000 ".f.actionbuttons.replicas.message delete $i"
   } else { 
      if {$howmanyentries > 1} {
         set echotext "You must select only one entry" 
         set i [.f.actionbuttons.replicas.message create text 6c 0.3c -text "$echotext" -fill red -anchor nw]
         after 1000 ".f.actionbuttons.replicas.message delete $i"
      } else {
         set repname [lindex $children [lindex $cs 0]]
         destroy .
	 global errorCode
         catch {exec /usr/coda/bin/filerepair $oname $oname/$repname}
	 puts stdout "repaired by $oname/$repname"
         exit 2
      }
   }
}

#proc invoked when ok is pressed with the button "use another file" is on
proc repairwithnamedfile {entry} {
   global oname 
   set cs [$entry get]
   set fnamelength [llength $cs]
   if {$fnamelength <= 0} {
      set echotext "You need to enter the name of a file first" 
      set i [.f.actionbuttons.replicas.message create text 6c 0.3c -text "$echotext" -fill red -anchor nw]
      after 1000 ".f.actionbuttons.replicas.message delete $i"
   } else {
      if {[file exists $cs] == 0} {
         set echotext  "$cs does not exist"
         set i [.f.actionbuttons.replicas.message create text 6c 0.3c -text "$echotext" -fill red -anchor nw]
         after 1000 ".f.actionbuttons.replicas.message delete $i"
      } elseif {[file isfile $cs] == 0} {
         set echotext "$cs isn't a file"
         set i [.f.actionbuttons.replicas.message create text 6c 0.3c -text "$echotext" -fill red -anchor nw]
         after 1000 ".f.actionbuttons.replicas.message delete $i"         
      } else {
	 catch {exec /usr/coda/bin/filerepair $oname $cs}
         puts stdout "repaired by $cs"
         exit 3
      }
   }
}

set action nothing 
frame .f -bd 2 -relief flat -background black 

set dname [lindex $argv 0]
set fname [lindex $argv 1]
set oname "$dname/$fname"
set children [exec ls $oname]
set nreplicas [llength $children]

GetIncResp

pack append . .f {top}
